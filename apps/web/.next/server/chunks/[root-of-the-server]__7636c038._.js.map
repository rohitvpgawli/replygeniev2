{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/db/schema.ts"],"sourcesContent":["import {\n  pgTable,\n  serial,\n  varchar,\n  text,\n  timestamp,\n  integer,\n  boolean,\n  jsonb,\n  index,\n  unique,\n} from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 100 }),\n  email: varchar('email', { length: 255 }).notNull().unique(),\n  passwordHash: text('password_hash').notNull(),\n  role: varchar('role', { length: 20 }).notNull().default('member'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n  deletedAt: timestamp('deleted_at'),\n});\n\nexport const teams = pgTable('teams', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 100 }).notNull(),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n  stripeCustomerId: text('stripe_customer_id').unique(),\n  stripeSubscriptionId: text('stripe_subscription_id').unique(),\n  stripeProductId: text('stripe_product_id'),\n  planName: varchar('plan_name', { length: 50 }),\n  subscriptionStatus: varchar('subscription_status', { length: 20 }),\n  brandVoiceGuidance: text('brand_voice_guidance'),\n  contactChannel: varchar('contact_channel', { length: 255 }),\n});\n\nexport const teamMembers = pgTable('team_members', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id')\n    .notNull()\n    .references(() => users.id),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  role: varchar('role', { length: 50 }).notNull(),\n  joinedAt: timestamp('joined_at').notNull().defaultNow(),\n});\n\nexport const activityLogs = pgTable('activity_logs', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  userId: integer('user_id').references(() => users.id),\n  action: text('action').notNull(),\n  timestamp: timestamp('timestamp').notNull().defaultNow(),\n  ipAddress: varchar('ip_address', { length: 45 }),\n});\n\nexport const invitations = pgTable('invitations', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).notNull(),\n  invitedBy: integer('invited_by')\n    .notNull()\n    .references(() => users.id),\n  invitedAt: timestamp('invited_at').notNull().defaultNow(),\n  status: varchar('status', { length: 20 }).notNull().default('pending'),\n});\n\n// ReplyGenie Tables\nexport const rcConnections = pgTable('rc_connections', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  provider: varchar('provider', { length: 50 }).notNull().default('google'),\n  accessToken: text('access_token'), // Encrypted\n  refreshToken: text('refresh_token'), // Encrypted\n  tokenExpiresAt: timestamp('token_expires_at'),\n  scope: text('scope'),\n  connectedBy: integer('connected_by')\n    .notNull()\n    .references(() => users.id),\n  connectedAt: timestamp('connected_at').notNull().defaultNow(),\n  lastSyncAt: timestamp('last_sync_at'),\n  status: varchar('status', { length: 20 }).notNull().default('active'),\n});\n\nexport const rcLocations = pgTable('rc_locations', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  connectionId: integer('connection_id')\n    .notNull()\n    .references(() => rcConnections.id),\n  googleLocationId: varchar('google_location_id', { length: 255 }).notNull(),\n  name: varchar('name', { length: 255 }).notNull(),\n  address: text('address'),\n  phoneNumber: varchar('phone_number', { length: 50 }),\n  websiteUrl: text('website_url'),\n  isVerified: boolean('is_verified').notNull().default(false),\n  syncCursor: timestamp('sync_cursor'), // For incremental sync\n  lastSyncAt: timestamp('last_sync_at'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n}, (table) => ({\n  googleLocationIdIdx: index('rc_locations_google_location_id_idx').on(table.googleLocationId),\n  teamIdIdx: index('rc_locations_team_id_idx').on(table.teamId),\n}));\n\nexport const rcReviews = pgTable('rc_reviews', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  locationId: integer('location_id')\n    .notNull()\n    .references(() => rcLocations.id),\n  googleReviewId: varchar('google_review_id', { length: 255 }).notNull().unique(),\n  reviewerName: varchar('reviewer_name', { length: 255 }),\n  reviewerProfilePhotoUrl: text('reviewer_profile_photo_url'),\n  starRating: integer('star_rating').notNull(),\n  comment: text('comment'),\n  reviewCreateTime: timestamp('review_create_time').notNull(),\n  reviewUpdateTime: timestamp('review_update_time'),\n  replied: boolean('replied').notNull().default(false),\n  status: varchar('status', { length: 20 }).notNull().default('pending'), // pending, drafted, posted\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n}, (table) => ({\n  locationIdCreateTimeIdx: index('rc_reviews_location_id_create_time_idx').on(table.locationId, table.reviewCreateTime),\n  googleReviewIdIdx: index('rc_reviews_google_review_id_idx').on(table.googleReviewId),\n  teamIdIdx: index('rc_reviews_team_id_idx').on(table.teamId),\n}));\n\nexport const rcDrafts = pgTable('rc_drafts', {\n  id: serial('id').primaryKey(),\n  reviewId: integer('review_id')\n    .notNull()\n    .references(() => rcReviews.id),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  draftText: text('draft_text').notNull(),\n  wordCount: integer('word_count').notNull(),\n  charCount: integer('char_count').notNull(),\n  riskFlags: jsonb('risk_flags'), // { hasUrl: boolean, hasProfanity: boolean, tooLong: boolean }\n  generatedBy: varchar('generated_by', { length: 50 }).notNull().default('ai'), // ai, user\n  generatedAt: timestamp('generated_at').notNull().defaultNow(),\n  editedBy: integer('edited_by').references(() => users.id),\n  editedAt: timestamp('edited_at'),\n});\n\nexport const rcReplies = pgTable('rc_replies', {\n  id: serial('id').primaryKey(),\n  reviewId: integer('review_id')\n    .notNull()\n    .references(() => rcReviews.id),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  replyText: text('reply_text').notNull(),\n  postedBy: integer('posted_by')\n    .notNull()\n    .references(() => users.id),\n  postedAt: timestamp('posted_at').notNull().defaultNow(),\n  googleReplyId: varchar('google_reply_id', { length: 255 }),\n  googleUpdateTime: timestamp('google_update_time'),\n}, (table) => ({\n  reviewIdUnique: unique('rc_replies_review_id_unique').on(table.reviewId),\n}));\n\nexport const rcUsage = pgTable('rc_usage', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  month: varchar('month', { length: 7 }).notNull(), // YYYY-MM format\n  postsCount: integer('posts_count').notNull().default(0),\n  draftsCount: integer('drafts_count').notNull().default(0),\n  quotaLimit: integer('quota_limit').notNull().default(50),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n}, (table) => ({\n  teamIdMonthUnique: unique('rc_usage_team_id_month_unique').on(table.teamId, table.month),\n}));\n\nexport const rcAuditLogs = pgTable('rc_audit_logs', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id')\n    .notNull()\n    .references(() => teams.id),\n  userId: integer('user_id').references(() => users.id),\n  action: varchar('action', { length: 100 }).notNull(), // DRAFT_GENERATED, REPLY_POSTED, LOCATION_SYNCED, etc.\n  entityType: varchar('entity_type', { length: 50 }).notNull(), // review, draft, reply, location, connection\n  entityId: integer('entity_id'),\n  oldValue: jsonb('old_value'),\n  newValue: jsonb('new_value'),\n  metadata: jsonb('metadata'),\n  ipAddress: varchar('ip_address', { length: 45 }),\n  userAgent: text('user_agent'),\n  timestamp: timestamp('timestamp').notNull().defaultNow(),\n}, (table) => ({\n  teamIdTimestampIdx: index('rc_audit_logs_team_id_timestamp_idx').on(table.teamId, table.timestamp),\n}));\n\nexport const teamsRelations = relations(teams, ({ many }) => ({\n  teamMembers: many(teamMembers),\n  activityLogs: many(activityLogs),\n  invitations: many(invitations),\n}));\n\nexport const usersRelations = relations(users, ({ many }) => ({\n  teamMembers: many(teamMembers),\n  invitationsSent: many(invitations),\n}));\n\nexport const invitationsRelations = relations(invitations, ({ one }) => ({\n  team: one(teams, {\n    fields: [invitations.teamId],\n    references: [teams.id],\n  }),\n  invitedBy: one(users, {\n    fields: [invitations.invitedBy],\n    references: [users.id],\n  }),\n}));\n\nexport const teamMembersRelations = relations(teamMembers, ({ one }) => ({\n  user: one(users, {\n    fields: [teamMembers.userId],\n    references: [users.id],\n  }),\n  team: one(teams, {\n    fields: [teamMembers.teamId],\n    references: [teams.id],\n  }),\n}));\n\nexport const activityLogsRelations = relations(activityLogs, ({ one }) => ({\n  team: one(teams, {\n    fields: [activityLogs.teamId],\n    references: [teams.id],\n  }),\n  user: one(users, {\n    fields: [activityLogs.userId],\n    references: [users.id],\n  }),\n}));\n\nexport type User = typeof users.$inferSelect;\nexport type NewUser = typeof users.$inferInsert;\nexport type Team = typeof teams.$inferSelect;\nexport type NewTeam = typeof teams.$inferInsert;\nexport type TeamMember = typeof teamMembers.$inferSelect;\nexport type NewTeamMember = typeof teamMembers.$inferInsert;\nexport type ActivityLog = typeof activityLogs.$inferSelect;\nexport type NewActivityLog = typeof activityLogs.$inferInsert;\nexport type Invitation = typeof invitations.$inferSelect;\nexport type NewInvitation = typeof invitations.$inferInsert;\nexport type TeamDataWithMembers = Team & {\n  teamMembers: (TeamMember & {\n    user: Pick<User, 'id' | 'name' | 'email'>;\n  })[];\n};\n\nexport enum ActivityType {\n  SIGN_UP = 'SIGN_UP',\n  SIGN_IN = 'SIGN_IN',\n  SIGN_OUT = 'SIGN_OUT',\n  UPDATE_PASSWORD = 'UPDATE_PASSWORD',\n  DELETE_ACCOUNT = 'DELETE_ACCOUNT',\n  UPDATE_ACCOUNT = 'UPDATE_ACCOUNT',\n  CREATE_TEAM = 'CREATE_TEAM',\n  REMOVE_TEAM_MEMBER = 'REMOVE_TEAM_MEMBER',\n  INVITE_TEAM_MEMBER = 'INVITE_TEAM_MEMBER',\n  ACCEPT_INVITATION = 'ACCEPT_INVITATION',\n}\n\n// ReplyGenie Types\nexport type RcConnection = typeof rcConnections.$inferSelect;\nexport type NewRcConnection = typeof rcConnections.$inferInsert;\nexport type RcLocation = typeof rcLocations.$inferSelect;\nexport type NewRcLocation = typeof rcLocations.$inferInsert;\nexport type RcReview = typeof rcReviews.$inferSelect;\nexport type NewRcReview = typeof rcReviews.$inferInsert;\nexport type RcDraft = typeof rcDrafts.$inferSelect;\nexport type NewRcDraft = typeof rcDrafts.$inferInsert;\nexport type RcReply = typeof rcReplies.$inferSelect;\nexport type NewRcReply = typeof rcReplies.$inferInsert;\nexport type RcUsage = typeof rcUsage.$inferSelect;\nexport type NewRcUsage = typeof rcUsage.$inferInsert;\nexport type RcAuditLog = typeof rcAuditLogs.$inferSelect;\nexport type NewRcAuditLog = typeof rcAuditLogs.$inferInsert;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 438, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/db/drizzle.ts"],"sourcesContent":["import { drizzle } from 'drizzle-orm/postgres-js';\nimport postgres from 'postgres';\nimport * as schema from './schema';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nif (!process.env.POSTGRES_URL) {\n  throw new Error('POSTGRES_URL environment variable is not set');\n}\n\nexport const client = postgres(process.env.POSTGRES_URL);\nexport const db = drizzle(client, { schema });\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,2LAAA,CAAA,UAAM,CAAC,MAAM;AAEb,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;IAC7B,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,SAAS,CAAA,GAAA,+LAAA,CAAA,UAAQ,AAAD,EAAE,QAAQ,GAAG,CAAC,YAAY;AAChD,MAAM,KAAK,CAAA,GAAA,gPAAA,CAAA,UAAO,AAAD,EAAE,QAAQ;IAAE,QAAA;AAAO","debugId":null}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/auth/session.ts"],"sourcesContent":["import { compare, hash } from 'bcryptjs';\nimport { SignJWT, jwtVerify } from 'jose';\nimport { cookies } from 'next/headers';\nimport { NewUser } from '@/lib/db/schema';\n\nconst key = new TextEncoder().encode(process.env.AUTH_SECRET);\nconst SALT_ROUNDS = 10;\n\nexport async function hashPassword(password: string) {\n  return hash(password, SALT_ROUNDS);\n}\n\nexport async function comparePasswords(\n  plainTextPassword: string,\n  hashedPassword: string\n) {\n  return compare(plainTextPassword, hashedPassword);\n}\n\ntype SessionData = {\n  user: { id: number };\n  expires: string;\n};\n\nexport async function signToken(payload: SessionData) {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime('1 day from now')\n    .sign(key);\n}\n\nexport async function verifyToken(input: string) {\n  const { payload } = await jwtVerify(input, key, {\n    algorithms: ['HS256'],\n  });\n  return payload as SessionData;\n}\n\nexport async function getSession() {\n  const session = (await cookies()).get('session')?.value;\n  if (!session) return null;\n  return await verifyToken(session);\n}\n\nexport async function setSession(user: NewUser) {\n  const expiresInOneDay = new Date(Date.now() + 24 * 60 * 60 * 1000);\n  const session: SessionData = {\n    user: { id: user.id! },\n    expires: expiresInOneDay.toISOString(),\n  };\n  const encryptedSession = await signToken(session);\n  (await cookies()).set('session', encryptedSession, {\n    expires: expiresInOneDay,\n    httpOnly: true,\n    secure: true,\n    sameSite: 'lax',\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AAAA;AACA;;;;AAGA,MAAM,MAAM,IAAI,cAAc,MAAM,CAAC,QAAQ,GAAG,CAAC,WAAW;AAC5D,MAAM,cAAc;AAEb,eAAe,aAAa,QAAgB;IACjD,OAAO,CAAA,GAAA,wLAAA,CAAA,OAAI,AAAD,EAAE,UAAU;AACxB;AAEO,eAAe,iBACpB,iBAAyB,EACzB,cAAsB;IAEtB,OAAO,CAAA,GAAA,wLAAA,CAAA,UAAO,AAAD,EAAE,mBAAmB;AACpC;AAOO,eAAe,UAAU,OAAoB;IAClD,OAAO,MAAM,IAAI,wMAAA,CAAA,UAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,kBAClB,IAAI,CAAC;AACV;AAEO,eAAe,YAAY,KAAa;IAC7C,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,0MAAA,CAAA,YAAS,AAAD,EAAE,OAAO,KAAK;QAC9C,YAAY;YAAC;SAAQ;IACvB;IACA,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,UAAU,CAAC,MAAM,CAAA,GAAA,gRAAA,CAAA,UAAO,AAAD,GAAG,EAAE,GAAG,CAAC,YAAY;IAClD,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,WAAW,IAAa;IAC5C,MAAM,kBAAkB,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK;IAC7D,MAAM,UAAuB;QAC3B,MAAM;YAAE,IAAI,KAAK,EAAE;QAAE;QACrB,SAAS,gBAAgB,WAAW;IACtC;IACA,MAAM,mBAAmB,MAAM,UAAU;IACzC,CAAC,MAAM,CAAA,GAAA,gRAAA,CAAA,UAAO,AAAD,GAAG,EAAE,GAAG,CAAC,WAAW,kBAAkB;QACjD,SAAS;QACT,UAAU;QACV,QAAQ;QACR,UAAU;IACZ;AACF","debugId":null}},
    {"offset": {"line": 523, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/db/queries.ts"],"sourcesContent":["import { desc, and, eq, isNull } from 'drizzle-orm';\nimport { db } from './drizzle';\nimport { activityLogs, teamMembers, teams, users } from './schema';\nimport { cookies } from 'next/headers';\nimport { verifyToken } from '@/lib/auth/session';\n\nexport async function getUser() {\n  const sessionCookie = (await cookies()).get('session');\n  if (!sessionCookie || !sessionCookie.value) {\n    return null;\n  }\n\n  const sessionData = await verifyToken(sessionCookie.value);\n  if (\n    !sessionData ||\n    !sessionData.user ||\n    typeof sessionData.user.id !== 'number'\n  ) {\n    return null;\n  }\n\n  if (new Date(sessionData.expires) < new Date()) {\n    return null;\n  }\n\n  const user = await db\n    .select()\n    .from(users)\n    .where(and(eq(users.id, sessionData.user.id), isNull(users.deletedAt)))\n    .limit(1);\n\n  if (user.length === 0) {\n    return null;\n  }\n\n  return user[0];\n}\n\nexport async function getTeamByStripeCustomerId(customerId: string) {\n  const result = await db\n    .select()\n    .from(teams)\n    .where(eq(teams.stripeCustomerId, customerId))\n    .limit(1);\n\n  return result.length > 0 ? result[0] : null;\n}\n\nexport async function updateTeamSubscription(\n  teamId: number,\n  subscriptionData: {\n    stripeSubscriptionId: string | null;\n    stripeProductId: string | null;\n    planName: string | null;\n    subscriptionStatus: string;\n  }\n) {\n  await db\n    .update(teams)\n    .set({\n      ...subscriptionData,\n      updatedAt: new Date()\n    })\n    .where(eq(teams.id, teamId));\n}\n\nexport async function getUserWithTeam(userId: number) {\n  const result = await db\n    .select({\n      user: users,\n      teamId: teamMembers.teamId\n    })\n    .from(users)\n    .leftJoin(teamMembers, eq(users.id, teamMembers.userId))\n    .where(eq(users.id, userId))\n    .limit(1);\n\n  return result[0];\n}\n\nexport async function getActivityLogs() {\n  const user = await getUser();\n  if (!user) {\n    throw new Error('User not authenticated');\n  }\n\n  return await db\n    .select({\n      id: activityLogs.id,\n      action: activityLogs.action,\n      timestamp: activityLogs.timestamp,\n      ipAddress: activityLogs.ipAddress,\n      userName: users.name\n    })\n    .from(activityLogs)\n    .leftJoin(users, eq(activityLogs.userId, users.id))\n    .where(eq(activityLogs.userId, user.id))\n    .orderBy(desc(activityLogs.timestamp))\n    .limit(10);\n}\n\nexport async function getTeamForUser() {\n  const user = await getUser();\n  if (!user) {\n    return null;\n  }\n\n  const result = await db.query.teamMembers.findFirst({\n    where: eq(teamMembers.userId, user.id),\n    with: {\n      team: {\n        with: {\n          teamMembers: {\n            with: {\n              user: {\n                columns: {\n                  id: true,\n                  name: true,\n                  email: true\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n\n  return result?.team || null;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 621, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/google/gbp-client.ts"],"sourcesContent":["/**\n * Google Business Profile API Client\n * Handles interactions with Google My Business API\n */\n\nconst GBP_API_BASE = 'https://mybusiness.googleapis.com/v4';\nconst GBP_API_V1_BASE = 'https://mybusinessbusinessinformation.googleapis.com/v1';\n\ninterface GbpLocation {\n  name: string; // Format: accounts/{accountId}/locations/{locationId}\n  locationName: string;\n  primaryPhone?: string;\n  websiteUri?: string;\n  locationState?: {\n    isVerified?: boolean;\n  };\n  storefrontAddress?: {\n    addressLines?: string[];\n    locality?: string;\n    administrativeArea?: string;\n    postalCode?: string;\n    regionCode?: string;\n  };\n}\n\ninterface GbpReview {\n  name: string; // Format: accounts/{accountId}/locations/{locationId}/reviews/{reviewId}\n  reviewId: string;\n  reviewer: {\n    displayName: string;\n    profilePhotoUrl?: string;\n  };\n  starRating: 'ONE' | 'TWO' | 'THREE' | 'FOUR' | 'FIVE';\n  comment?: string;\n  createTime: string;\n  updateTime: string;\n  reviewReply?: {\n    comment: string;\n    updateTime: string;\n  };\n}\n\ninterface GbpAccount {\n  name: string; // Format: accounts/{accountId}\n  accountName: string;\n  type: string;\n}\n\n/**\n * Retry helper with exponential backoff\n */\nasync function fetchWithRetry(\n  url: string,\n  options: RequestInit,\n  maxRetries: number = 3\n): Promise<Response> {\n  let lastError: Error | null = null;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      const response = await fetch(url, options);\n      \n      // If rate limited, wait and retry\n      if (response.status === 429) {\n        const retryAfter = response.headers.get('Retry-After');\n        const waitTime = retryAfter \n          ? parseInt(retryAfter) * 1000 \n          : Math.min(1000 * Math.pow(2, attempt), 10000); // Max 10s\n        \n        console.log(`Rate limited. Waiting ${waitTime}ms before retry ${attempt + 1}/${maxRetries}`);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n        continue;\n      }\n      \n      return response;\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error('Unknown error');\n      if (attempt < maxRetries - 1) {\n        const waitTime = Math.min(1000 * Math.pow(2, attempt), 10000);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n  }\n  \n  throw lastError || new Error('Max retries exceeded');\n}\n\n/**\n * Fetches all accounts accessible by the access token\n */\nexport async function fetchAccounts(accessToken: string): Promise<GbpAccount[]> {\n  const response = await fetchWithRetry(`${GBP_API_V1_BASE}/accounts`, {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Failed to fetch accounts:', error);\n    throw new Error(`Failed to fetch accounts: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.accounts || [];\n}\n\n/**\n * Fetches all locations for an account\n */\nexport async function fetchLocations(\n  accessToken: string,\n  accountId: string\n): Promise<GbpLocation[]> {\n  const response = await fetchWithRetry(\n    `${GBP_API_V1_BASE}/accounts/${accountId}/locations?readMask=name,title,phoneNumbers,websiteUri,storefrontAddress,metadata`,\n    {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }\n  );\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Failed to fetch locations:', error);\n    throw new Error(`Failed to fetch locations: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.locations || [];\n}\n\n/**\n * Fetches reviews for a location with pagination support\n */\nexport async function fetchReviews(\n  accessToken: string,\n  locationName: string, // Format: accounts/{accountId}/locations/{locationId}\n  pageSize: number = 50,\n  pageToken?: string\n): Promise<{ reviews: GbpReview[]; nextPageToken?: string }> {\n  const params = new URLSearchParams({\n    pageSize: pageSize.toString(),\n  });\n\n  if (pageToken) {\n    params.append('pageToken', pageToken);\n  }\n\n  const response = await fetchWithRetry(\n    `${GBP_API_BASE}/${locationName}/reviews?${params.toString()}`,\n    {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }\n  );\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Failed to fetch reviews:', error);\n    throw new Error(`Failed to fetch reviews: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return {\n    reviews: data.reviews || [],\n    nextPageToken: data.nextPageToken,\n  };\n}\n\n/**\n * Posts a reply to a review\n */\nexport async function postReviewReply(\n  accessToken: string,\n  reviewName: string, // Format: accounts/{accountId}/locations/{locationId}/reviews/{reviewId}\n  replyText: string\n): Promise<void> {\n  const response = await fetch(`${GBP_API_BASE}/${reviewName}/reply`, {\n    method: 'PUT',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      comment: replyText,\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Failed to post reply:', error);\n    throw new Error(`Failed to post reply: ${response.status}`);\n  }\n}\n\n/**\n * Converts star rating enum to number\n */\nexport function starRatingToNumber(rating: string): number {\n  const map: Record<string, number> = {\n    ONE: 1,\n    TWO: 2,\n    THREE: 3,\n    FOUR: 4,\n    FIVE: 5,\n  };\n  return map[rating] || 0;\n}\n\n/**\n * Formats address from GBP format to string\n */\nexport function formatAddress(address?: GbpLocation['storefrontAddress']): string {\n  if (!address) return '';\n\n  const parts = [\n    ...(address.addressLines || []),\n    address.locality,\n    address.administrativeArea,\n    address.postalCode,\n  ].filter(Boolean);\n\n  return parts.join(', ');\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/encryption.ts"],"sourcesContent":["import crypto from 'crypto';\n\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 16;\nconst SALT_LENGTH = 64;\nconst TAG_LENGTH = 16;\nconst KEY_LENGTH = 32;\n\n/**\n * Derives a key from the encryption key using PBKDF2\n */\nfunction deriveKey(password: string, salt: Buffer): Buffer {\n  return crypto.pbkdf2Sync(password, salt, 100000, KEY_LENGTH, 'sha256');\n}\n\n/**\n * Encrypts a string using AES-256-GCM\n * @param text - The text to encrypt\n * @returns Encrypted string in format: salt:iv:authTag:encryptedData (all base64)\n */\nexport function encrypt(text: string): string {\n  const encryptionKey = process.env.TOKEN_ENCRYPTION_KEY;\n  \n  if (!encryptionKey) {\n    throw new Error('TOKEN_ENCRYPTION_KEY environment variable is not set');\n  }\n\n  // Generate random salt and IV\n  const salt = crypto.randomBytes(SALT_LENGTH);\n  const iv = crypto.randomBytes(IV_LENGTH);\n  \n  // Derive key from encryption key\n  const key = deriveKey(encryptionKey, salt);\n  \n  // Create cipher\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n  \n  // Encrypt the text\n  let encrypted = cipher.update(text, 'utf8', 'base64');\n  encrypted += cipher.final('base64');\n  \n  // Get auth tag\n  const authTag = cipher.getAuthTag();\n  \n  // Return salt:iv:authTag:encryptedData\n  return [\n    salt.toString('base64'),\n    iv.toString('base64'),\n    authTag.toString('base64'),\n    encrypted,\n  ].join(':');\n}\n\n/**\n * Decrypts a string encrypted with the encrypt function\n * @param encryptedText - The encrypted text in format: salt:iv:authTag:encryptedData\n * @returns Decrypted string\n */\nexport function decrypt(encryptedText: string): string {\n  const encryptionKey = process.env.TOKEN_ENCRYPTION_KEY;\n  \n  if (!encryptionKey) {\n    throw new Error('TOKEN_ENCRYPTION_KEY environment variable is not set');\n  }\n\n  // Split the encrypted text\n  const parts = encryptedText.split(':');\n  \n  if (parts.length !== 4) {\n    throw new Error('Invalid encrypted text format');\n  }\n\n  const [saltB64, ivB64, authTagB64, encrypted] = parts;\n  \n  // Convert from base64\n  const salt = Buffer.from(saltB64, 'base64');\n  const iv = Buffer.from(ivB64, 'base64');\n  const authTag = Buffer.from(authTagB64, 'base64');\n  \n  // Derive key\n  const key = deriveKey(encryptionKey, salt);\n  \n  // Create decipher\n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(authTag);\n  \n  // Decrypt\n  let decrypted = decipher.update(encrypted, 'base64', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n\n/**\n * Safely encrypts a token, returns null if token is null/undefined\n */\nexport function encryptToken(token: string | null | undefined): string | null {\n  if (!token) return null;\n  return encrypt(token);\n}\n\n/**\n * Safely decrypts a token, returns null if token is null/undefined\n */\nexport function decryptToken(encryptedToken: string | null | undefined): string | null {\n  if (!encryptedToken) return null;\n  try {\n    return decrypt(encryptedToken);\n  } catch (error) {\n    console.error('Failed to decrypt token:', error);\n    return null;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,MAAM,cAAc;AACpB,MAAM,aAAa;AACnB,MAAM,aAAa;AAEnB;;CAEC,GACD,SAAS,UAAU,QAAgB,EAAE,IAAY;IAC/C,OAAO,qGAAA,CAAA,UAAM,CAAC,UAAU,CAAC,UAAU,MAAM,QAAQ,YAAY;AAC/D;AAOO,SAAS,QAAQ,IAAY;IAClC,MAAM,gBAAgB,QAAQ,GAAG,CAAC,oBAAoB;IAEtD,IAAI,CAAC,eAAe;QAClB,MAAM,IAAI,MAAM;IAClB;IAEA,8BAA8B;IAC9B,MAAM,OAAO,qGAAA,CAAA,UAAM,CAAC,WAAW,CAAC;IAChC,MAAM,KAAK,qGAAA,CAAA,UAAM,CAAC,WAAW,CAAC;IAE9B,iCAAiC;IACjC,MAAM,MAAM,UAAU,eAAe;IAErC,gBAAgB;IAChB,MAAM,SAAS,qGAAA,CAAA,UAAM,CAAC,cAAc,CAAC,WAAW,KAAK;IAErD,mBAAmB;IACnB,IAAI,YAAY,OAAO,MAAM,CAAC,MAAM,QAAQ;IAC5C,aAAa,OAAO,KAAK,CAAC;IAE1B,eAAe;IACf,MAAM,UAAU,OAAO,UAAU;IAEjC,uCAAuC;IACvC,OAAO;QACL,KAAK,QAAQ,CAAC;QACd,GAAG,QAAQ,CAAC;QACZ,QAAQ,QAAQ,CAAC;QACjB;KACD,CAAC,IAAI,CAAC;AACT;AAOO,SAAS,QAAQ,aAAqB;IAC3C,MAAM,gBAAgB,QAAQ,GAAG,CAAC,oBAAoB;IAEtD,IAAI,CAAC,eAAe;QAClB,MAAM,IAAI,MAAM;IAClB;IAEA,2BAA2B;IAC3B,MAAM,QAAQ,cAAc,KAAK,CAAC;IAElC,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,CAAC,SAAS,OAAO,YAAY,UAAU,GAAG;IAEhD,sBAAsB;IACtB,MAAM,OAAO,OAAO,IAAI,CAAC,SAAS;IAClC,MAAM,KAAK,OAAO,IAAI,CAAC,OAAO;IAC9B,MAAM,UAAU,OAAO,IAAI,CAAC,YAAY;IAExC,aAAa;IACb,MAAM,MAAM,UAAU,eAAe;IAErC,kBAAkB;IAClB,MAAM,WAAW,qGAAA,CAAA,UAAM,CAAC,gBAAgB,CAAC,WAAW,KAAK;IACzD,SAAS,UAAU,CAAC;IAEpB,UAAU;IACV,IAAI,YAAY,SAAS,MAAM,CAAC,WAAW,UAAU;IACrD,aAAa,SAAS,KAAK,CAAC;IAE5B,OAAO;AACT;AAKO,SAAS,aAAa,KAAgC;IAC3D,IAAI,CAAC,OAAO,OAAO;IACnB,OAAO,QAAQ;AACjB;AAKO,SAAS,aAAa,cAAyC;IACpE,IAAI,CAAC,gBAAgB,OAAO;IAC5B,IAAI;QACF,OAAO,QAAQ;IACjB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 837, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/google/oauth.ts"],"sourcesContent":["import { db } from '@/lib/db/drizzle';\nimport { rcConnections } from '@/lib/db/schema';\nimport { eq, and } from 'drizzle-orm';\nimport { decryptToken, encryptToken } from '@/lib/encryption';\n\nconst GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';\n\ninterface GoogleTokenResponse {\n  access_token: string;\n  expires_in: number;\n  scope: string;\n  token_type: string;\n}\n\n/**\n * Gets a valid access token for a team's Google connection\n * Automatically refreshes if expired\n */\nexport async function getValidAccessToken(teamId: number): Promise<string | null> {\n  try {\n    // Get the connection\n    const [connection] = await db\n      .select()\n      .from(rcConnections)\n      .where(\n        and(\n          eq(rcConnections.teamId, teamId),\n          eq(rcConnections.provider, 'google'),\n          eq(rcConnections.status, 'active')\n        )\n      )\n      .limit(1);\n\n    if (!connection) {\n      return null;\n    }\n\n    // Check if token is still valid (with 5 minute buffer)\n    const now = new Date();\n    const expiryWithBuffer = new Date(\n      connection.tokenExpiresAt!.getTime() - 5 * 60 * 1000\n    );\n\n    if (now < expiryWithBuffer) {\n      // Token is still valid, decrypt and return\n      return decryptToken(connection.accessToken);\n    }\n\n    // Token expired, refresh it\n    const refreshToken = decryptToken(connection.refreshToken);\n    if (!refreshToken) {\n      console.error('No refresh token available');\n      return null;\n    }\n\n    const tokenResponse = await fetch(GOOGLE_TOKEN_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        client_id: process.env.GOOGLE_CLIENT_ID!,\n        client_secret: process.env.GOOGLE_CLIENT_SECRET!,\n        refresh_token: refreshToken,\n        grant_type: 'refresh_token',\n      }),\n    });\n\n    if (!tokenResponse.ok) {\n      const errorData = await tokenResponse.text();\n      console.error('Token refresh failed:', errorData);\n      \n      // Mark connection as inactive if refresh fails\n      await db\n        .update(rcConnections)\n        .set({ status: 'inactive' })\n        .where(eq(rcConnections.id, connection.id));\n      \n      return null;\n    }\n\n    const tokens: GoogleTokenResponse = await tokenResponse.json();\n\n    // Encrypt new access token\n    const encryptedAccessToken = encryptToken(tokens.access_token);\n    if (!encryptedAccessToken) {\n      console.error('Failed to encrypt new access token');\n      return null;\n    }\n\n    // Calculate new expiry\n    const tokenExpiresAt = new Date(Date.now() + tokens.expires_in * 1000);\n\n    // Update connection with new token\n    await db\n      .update(rcConnections)\n      .set({\n        accessToken: encryptedAccessToken,\n        tokenExpiresAt,\n        scope: tokens.scope,\n      })\n      .where(eq(rcConnections.id, connection.id));\n\n    return tokens.access_token;\n  } catch (error) {\n    console.error('Error getting valid access token:', error);\n    return null;\n  }\n}\n\n/**\n * Refreshes an access token using a refresh token\n * Returns the new access token and expiry time\n */\nexport async function refreshAccessToken(encryptedRefreshToken: string): Promise<{\n  accessToken: string;\n  expiresAt: Date;\n}> {\n  const refreshToken = decryptToken(encryptedRefreshToken);\n  if (!refreshToken) {\n    throw new Error('Invalid refresh token');\n  }\n\n  const tokenResponse = await fetch(GOOGLE_TOKEN_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      client_id: process.env.GOOGLE_CLIENT_ID!,\n      client_secret: process.env.GOOGLE_CLIENT_SECRET!,\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token',\n    }),\n  });\n\n  if (!tokenResponse.ok) {\n    const errorData = await tokenResponse.text();\n    throw new Error(`Token refresh failed: ${errorData}`);\n  }\n\n  const tokens: GoogleTokenResponse = await tokenResponse.json();\n  const expiresAt = new Date(Date.now() + tokens.expires_in * 1000);\n\n  return {\n    accessToken: tokens.access_token,\n    expiresAt,\n  };\n}\n\n/**\n * Checks if a team has an active Google connection\n */\nexport async function hasActiveConnection(teamId: number): Promise<boolean> {\n  const [connection] = await db\n    .select()\n    .from(rcConnections)\n    .where(\n      and(\n        eq(rcConnections.teamId, teamId),\n        eq(rcConnections.provider, 'google'),\n        eq(rcConnections.status, 'active')\n      )\n    )\n    .limit(1);\n\n  return !!connection;\n}\n\n/**\n * Gets connection status for a team\n */\nexport async function getConnectionStatus(teamId: number) {\n  const [connection] = await db\n    .select({\n      id: rcConnections.id,\n      status: rcConnections.status,\n      connectedAt: rcConnections.connectedAt,\n      lastSyncAt: rcConnections.lastSyncAt,\n    })\n    .from(rcConnections)\n    .where(\n      and(\n        eq(rcConnections.teamId, teamId),\n        eq(rcConnections.provider, 'google')\n      )\n    )\n    .limit(1);\n\n  return connection || null;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/lib/services/review-sync.ts"],"sourcesContent":["import { db } from '@/lib/db/drizzle';\nimport { rcLocations, rcReviews, rcAuditLogs } from '@/lib/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { fetchReviews, starRatingToNumber } from '@/lib/google/gbp-client';\nimport { getValidAccessToken } from '@/lib/google/oauth';\n\ninterface SyncResult {\n  success: boolean;\n  newReviews: number;\n  totalReviews: number;\n  error?: string;\n}\n\n/**\n * Syncs reviews for a specific location\n * Implements incremental sync using sync_cursor\n */\nexport async function syncReviews(\n  locationId: number,\n  teamId: number,\n  userId: number\n): Promise<SyncResult> {\n  try {\n    // Get location details\n    const [location] = await db\n      .select()\n      .from(rcLocations)\n      .where(eq(rcLocations.id, locationId))\n      .limit(1);\n\n    if (!location) {\n      return {\n        success: false,\n        newReviews: 0,\n        totalReviews: 0,\n        error: 'Location not found',\n      };\n    }\n\n    // Verify location belongs to team\n    if (location.teamId !== teamId) {\n      return {\n        success: false,\n        newReviews: 0,\n        totalReviews: 0,\n        error: 'Unauthorized',\n      };\n    }\n\n    // Get valid access token\n    const accessToken = await getValidAccessToken(teamId);\n    if (!accessToken) {\n      return {\n        success: false,\n        newReviews: 0,\n        totalReviews: 0,\n        error: 'No valid access token',\n      };\n    }\n\n    let newReviewsCount = 0;\n    let totalReviewsCount = 0;\n    let pageToken: string | undefined;\n    const maxPages = 10; // Limit to prevent infinite loops\n    let pageCount = 0;\n\n    // Fetch reviews with pagination\n    do {\n      const { reviews, nextPageToken } = await fetchReviews(\n        accessToken,\n        location.googleLocationId,\n        50,\n        pageToken\n      );\n\n      totalReviewsCount += reviews.length;\n\n      // Process each review\n      for (const review of reviews) {\n        const reviewCreateTime = new Date(review.createTime);\n        const reviewUpdateTime = new Date(review.updateTime);\n\n        // Skip if review is older than sync cursor (already synced)\n        if (location.syncCursor && reviewCreateTime < location.syncCursor) {\n          continue;\n        }\n\n        // Check if review already exists\n        const [existingReview] = await db\n          .select()\n          .from(rcReviews)\n          .where(eq(rcReviews.googleReviewId, review.reviewId))\n          .limit(1);\n\n        if (existingReview) {\n          // Update existing review if it was modified\n          if (reviewUpdateTime > existingReview.reviewUpdateTime!) {\n            await db\n              .update(rcReviews)\n              .set({\n                reviewerName: review.reviewer.displayName,\n                reviewerProfilePhotoUrl: review.reviewer.profilePhotoUrl,\n                starRating: starRatingToNumber(review.starRating),\n                comment: review.comment,\n                reviewUpdateTime,\n                replied: !!review.reviewReply,\n                updatedAt: new Date(),\n              })\n              .where(eq(rcReviews.id, existingReview.id));\n          }\n        } else {\n          // Insert new review\n          await db.insert(rcReviews).values({\n            teamId,\n            locationId,\n            googleReviewId: review.reviewId,\n            reviewerName: review.reviewer.displayName,\n            reviewerProfilePhotoUrl: review.reviewer.profilePhotoUrl,\n            starRating: starRatingToNumber(review.starRating),\n            comment: review.comment,\n            reviewCreateTime,\n            reviewUpdateTime,\n            replied: !!review.reviewReply,\n            status: 'pending',\n          });\n\n          newReviewsCount++;\n        }\n      }\n\n      pageToken = nextPageToken;\n      pageCount++;\n    } while (pageToken && pageCount < maxPages);\n\n    // Update location's sync cursor and last sync time\n    await db\n      .update(rcLocations)\n      .set({\n        syncCursor: new Date(),\n        lastSyncAt: new Date(),\n        updatedAt: new Date(),\n      })\n      .where(eq(rcLocations.id, locationId));\n\n    // Create audit log\n    await db.insert(rcAuditLogs).values({\n      teamId,\n      userId,\n      action: 'REVIEWS_SYNCED',\n      entityType: 'location',\n      entityId: locationId,\n      metadata: {\n        newReviews: newReviewsCount,\n        totalReviews: totalReviewsCount,\n      },\n    });\n\n    return {\n      success: true,\n      newReviews: newReviewsCount,\n      totalReviews: totalReviewsCount,\n    };\n  } catch (error) {\n    console.error('Error syncing reviews:', error);\n    return {\n      success: false,\n      newReviews: 0,\n      totalReviews: 0,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Syncs locations from Google Business Profile\n */\nexport async function syncLocations(\n  teamId: number,\n  userId: number,\n  accountId: string\n): Promise<{ success: boolean; count: number; error?: string }> {\n  try {\n    const accessToken = await getValidAccessToken(teamId);\n    if (!accessToken) {\n      return {\n        success: false,\n        count: 0,\n        error: 'No valid access token',\n      };\n    }\n\n    // Import fetchLocations and formatAddress\n    const { fetchLocations, formatAddress } = await import('@/lib/google/gbp-client');\n    \n    const locations = await fetchLocations(accessToken, accountId);\n\n    let syncedCount = 0;\n\n    for (const location of locations) {\n      // Check if location already exists\n      const [existing] = await db\n        .select()\n        .from(rcLocations)\n        .where(eq(rcLocations.googleLocationId, location.name))\n        .limit(1);\n\n      const locationData = {\n        name: location.locationName,\n        address: formatAddress(location.storefrontAddress),\n        phoneNumber: location.primaryPhone,\n        websiteUrl: location.websiteUri,\n        isVerified: location.locationState?.isVerified || false,\n        updatedAt: new Date(),\n      };\n\n      if (existing) {\n        // Update existing location\n        await db\n          .update(rcLocations)\n          .set(locationData)\n          .where(eq(rcLocations.id, existing.id));\n      } else {\n        // Get connection ID\n        const { rcConnections } = await import('@/lib/db/schema');\n        const [connection] = await db\n          .select()\n          .from(rcConnections)\n          .where(eq(rcConnections.teamId, teamId))\n          .limit(1);\n\n        if (!connection) {\n          continue;\n        }\n\n        // Insert new location\n        await db.insert(rcLocations).values({\n          teamId,\n          connectionId: connection.id,\n          googleLocationId: location.name,\n          ...locationData,\n        });\n\n        syncedCount++;\n      }\n    }\n\n    // Create audit log\n    await db.insert(rcAuditLogs).values({\n      teamId,\n      userId,\n      action: 'LOCATIONS_SYNCED',\n      entityType: 'connection',\n      metadata: {\n        count: syncedCount,\n        accountId,\n      },\n    });\n\n    return {\n      success: true,\n      count: syncedCount,\n    };\n  } catch (error) {\n    console.error('Error syncing locations:', error);\n    return {\n      success: false,\n      count: 0,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1163, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitgawli/Documents/GitHub/replygeniev2/apps/web/app/api/v1/locations/sync/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getUser, getTeamForUser } from '@/lib/db/queries';\nimport { syncLocations } from '@/lib/services/review-sync';\nimport { fetchAccounts } from '@/lib/google/gbp-client';\nimport { getValidAccessToken } from '@/lib/google/oauth';\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Verify user is authenticated\n    const user = await getUser();\n    if (!user) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    // Get user's team\n    const team = await getTeamForUser();\n    if (!team) {\n      return NextResponse.json(\n        { error: 'No team found' },\n        { status: 404 }\n      );\n    }\n\n    // Get valid access token\n    const accessToken = await getValidAccessToken(team.id);\n    if (!accessToken) {\n      return NextResponse.json(\n        { error: 'No valid access token. Please reconnect your Google account.' },\n        { status: 401 }\n      );\n    }\n\n    // Fetch accounts\n    const accounts = await fetchAccounts(accessToken);\n    if (accounts.length === 0) {\n      return NextResponse.json(\n        { error: 'No Google Business accounts found' },\n        { status: 404 }\n      );\n    }\n\n    // Use the first account (most common case)\n    // Extract account ID from name format: \"accounts/{accountId}\"\n    const accountId = accounts[0].name.split('/')[1];\n\n    // Sync locations\n    const result = await syncLocations(team.id, user.id, accountId);\n\n    if (!result.success) {\n      return NextResponse.json(\n        { error: result.error || 'Failed to sync locations' },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json({\n      success: true,\n      count: result.count,\n    });\n  } catch (error) {\n    console.error('Error in locations sync endpoint:', error);\n    \n    // Provide helpful error messages\n    const errorMessage = error instanceof Error ? error.message : 'Internal server error';\n    \n    if (errorMessage.includes('429')) {\n      return NextResponse.json(\n        { \n          error: 'Google API rate limit reached. Please wait a few minutes and try again.',\n          retryAfter: 60 // seconds\n        },\n        { status: 429 }\n      );\n    }\n    \n    return NextResponse.json(\n      { error: errorMessage },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,+BAA+B;QAC/B,MAAM,OAAO,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD;QACzB,IAAI,CAAC,MAAM;YACT,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAe,GACxB;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,OAAO,MAAM,CAAA,GAAA,qIAAA,CAAA,iBAAc,AAAD;QAChC,IAAI,CAAC,MAAM;YACT,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAgB,GACzB;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,cAAc,MAAM,CAAA,GAAA,uIAAA,CAAA,sBAAmB,AAAD,EAAE,KAAK,EAAE;QACrD,IAAI,CAAC,aAAa;YAChB,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+D,GACxE;gBAAE,QAAQ;YAAI;QAElB;QAEA,iBAAiB;QACjB,MAAM,WAAW,MAAM,CAAA,GAAA,+IAAA,CAAA,gBAAa,AAAD,EAAE;QACrC,IAAI,SAAS,MAAM,KAAK,GAAG;YACzB,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoC,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,2CAA2C;QAC3C,8DAA8D;QAC9D,MAAM,YAAY,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAEhD,iBAAiB;QACjB,MAAM,SAAS,MAAM,CAAA,GAAA,kJAAA,CAAA,gBAAa,AAAD,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE;QAErD,IAAI,CAAC,OAAO,OAAO,EAAE;YACnB,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,OAAO,KAAK,IAAI;YAA2B,GACpD;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,OAAO,OAAO,KAAK;QACrB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QAEnD,iCAAiC;QACjC,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAE9D,IAAI,aAAa,QAAQ,CAAC,QAAQ;YAChC,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBACE,OAAO;gBACP,YAAY,GAAG,UAAU;YAC3B,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,+QAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAa,GACtB;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}